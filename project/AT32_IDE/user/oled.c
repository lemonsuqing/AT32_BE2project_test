#include "oled.h"
#include "wk_system.h"

// OLED屏幕参数定义
#define OLED_WIDTH       128
#define OLED_HEIGHT      64
#define OLED_PAGE_COUNT  8
#define OLED_I2C_ADDR    0x3C    // I2C地址(根据模块实际修改)
#define OLED_I2C         I2C2    // 使用的I2C外设

// 命令/数据区分
#define OLED_CMD         0x00
#define OLED_DATA        0x40

// 6x8 ASCII字符集（完整常用字符）
const uint8_t F6x8[][6] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // 空格(32)
    {0x00, 0x00, 0x2f, 0x00, 0x00, 0x00}, // !(33)
    {0x00, 0x07, 0x00, 0x07, 0x00, 0x00}, // "(34)
    {0x14, 0x7f, 0x14, 0x7f, 0x14, 0x00}, // #(35)
    {0x24, 0x2a, 0x7f, 0x2a, 0x12, 0x00}, // $(36)
    {0x23, 0x13, 0x08, 0x64, 0x62, 0x00}, // %(37)
    {0x36, 0x49, 0x55, 0x22, 0x50, 0x00}, // &(38)
    {0x00, 0x05, 0x03, 0x00, 0x00, 0x00}, // '(39)
    {0x00, 0x1c, 0x22, 0x41, 0x00, 0x00}, // ((40)
    {0x00, 0x41, 0x22, 0x1c, 0x00, 0x00}, // )(41)
    {0x14, 0x08, 0x3e, 0x08, 0x14, 0x00}, // *(42)
    {0x08, 0x08, 0x3e, 0x08, 0x08, 0x00}, // +(43)
    {0x00, 0x50, 0x30, 0x00, 0x00, 0x00}, // ,(44)
    {0x08, 0x08, 0x08, 0x08, 0x08, 0x00}, // -(45)
    {0x00, 0x60, 0x60, 0x00, 0x00, 0x00}, // .(46)
    {0x20, 0x10, 0x08, 0x04, 0x02, 0x00}, // /(47)
    {0x3e, 0x51, 0x49, 0x45, 0x3e, 0x00}, // 0(48)
    {0x00, 0x42, 0x7f, 0x40, 0x00, 0x00}, // 1(49)
    {0x42, 0x61, 0x51, 0x49, 0x46, 0x00}, // 2(50)
    {0x21, 0x41, 0x45, 0x4b, 0x31, 0x00}, // 3(51)
    {0x18, 0x14, 0x12, 0x7f, 0x10, 0x00}, // 4(52)
    {0x27, 0x45, 0x45, 0x45, 0x39, 0x00}, // 5(53)
    {0x3c, 0x4a, 0x49, 0x49, 0x30, 0x00}, // 6(54)
    {0x01, 0x71, 0x09, 0x05, 0x03, 0x00}, // 7(55)
    {0x36, 0x49, 0x49, 0x49, 0x36, 0x00}, // 8(56)
    {0x06, 0x49, 0x49, 0x29, 0x1e, 0x00}, // 9(57)
    {0x00, 0x00, 0x14, 0x00, 0x00, 0x00}, // :(58)
    {0x00, 0x40, 0x34, 0x00, 0x00, 0x00}, // ;(59)
    {0x00, 0x14, 0x22, 0x41, 0x00, 0x00}, // <(60)
    {0x14, 0x14, 0x14, 0x14, 0x14, 0x00}, // =(61)
    {0x00, 0x41, 0x22, 0x14, 0x00, 0x00}, // >(62)
    {0x02, 0x01, 0x51, 0x09, 0x06, 0x00}, // ?(63)
    {0x32, 0x49, 0x79, 0x41, 0x3e, 0x00}, // @(64)
    {0x7e, 0x11, 0x11, 0x11, 0x7e, 0x00}, // A(65)
    {0x7f, 0x49, 0x49, 0x49, 0x36, 0x00}, // B(66)
    {0x3e, 0x41, 0x41, 0x41, 0x22, 0x00}, // C(67)
    {0x7f, 0x41, 0x41, 0x22, 0x1c, 0x00}, // D(68)
    {0x7f, 0x49, 0x49, 0x49, 0x41, 0x00}, // E(69)
    {0x7f, 0x09, 0x09, 0x09, 0x01, 0x00}, // F(70)
    {0x3e, 0x41, 0x49, 0x49, 0x3a, 0x00}, // G(71)
    {0x7f, 0x08, 0x08, 0x08, 0x7f, 0x00}, // H(72)
    {0x00, 0x41, 0x7f, 0x41, 0x00, 0x00}, // I(73)
    {0x20, 0x40, 0x41, 0x3f, 0x01, 0x00}, // J(74)
    {0x7f, 0x08, 0x14, 0x22, 0x41, 0x00}, // K(75)
    {0x7f, 0x40, 0x40, 0x40, 0x40, 0x00}, // L(76)
    {0x7f, 0x02, 0x0c, 0x02, 0x7f, 0x00}, // M(77)
    {0x7f, 0x04, 0x08, 0x10, 0x7f, 0x00}, // N(78)
    {0x3e, 0x41, 0x41, 0x41, 0x3e, 0x00}, // O(79)
    {0x7f, 0x09, 0x09, 0x09, 0x06, 0x00}, // P(80)
    {0x3e, 0x41, 0x51, 0x21, 0x5e, 0x00}, // Q(81)
    {0x7f, 0x09, 0x19, 0x29, 0x46, 0x00}, // R(82)
    {0x46, 0x49, 0x49, 0x49, 0x31, 0x00}, // S(83)
    {0x01, 0x01, 0x7f, 0x01, 0x01, 0x00}, // T(84)
    {0x3f, 0x40, 0x40, 0x40, 0x3f, 0x00}, // U(85)
    {0x1f, 0x20, 0x40, 0x20, 0x1f, 0x00}, // V(86)
    {0x3f, 0x40, 0x30, 0x40, 0x3f, 0x00}, // W(87)
    {0x63, 0x14, 0x08, 0x14, 0x63, 0x00}, // X(88)
    {0x07, 0x08, 0x70, 0x08, 0x07, 0x00}, // Y(89)
    {0x61, 0x51, 0x49, 0x45, 0x43, 0x00}, // Z(90)
    {0x00, 0x7f, 0x41, 0x41, 0x00, 0x00}, // [(91)
    {0x02, 0x04, 0x08, 0x10, 0x20, 0x00}, // \(92)
    {0x00, 0x41, 0x41, 0x7f, 0x00, 0x00}, // ](93)
    {0x04, 0x02, 0x01, 0x02, 0x04, 0x00}, // ^(94)
    {0x40, 0x40, 0x40, 0x40, 0x40, 0x00}, // _(95)
    {0x00, 0x01, 0x02, 0x04, 0x00, 0x00}, // `(96)
    {0x20, 0x54, 0x54, 0x54, 0x78, 0x00}, // a(97)
    {0x7f, 0x48, 0x44, 0x44, 0x38, 0x00}, // b(98)
    {0x38, 0x44, 0x44, 0x44, 0x20, 0x00}, // c(99)
    {0x38, 0x44, 0x44, 0x48, 0x7f, 0x00}, // d(100)
    {0x38, 0x54, 0x54, 0x54, 0x18, 0x00}, // e(101)
    {0x08, 0x7e, 0x09, 0x01, 0x02, 0x00}, // f(102)
    {0x0c, 0x52, 0x52, 0x52, 0x3e, 0x00}, // g(103)
    {0x7f, 0x08, 0x04, 0x04, 0x78, 0x00}, // h(104)
    {0x00, 0x44, 0x7d, 0x40, 0x00, 0x00}, // i(105)
    {0x20, 0x40, 0x44, 0x3d, 0x00, 0x00}, // j(106)
    {0x7f, 0x10, 0x28, 0x44, 0x00, 0x00}, // k(107)
    {0x00, 0x41, 0x7f, 0x40, 0x00, 0x00}, // l(108)
    {0x7c, 0x04, 0x78, 0x04, 0x78, 0x00}, // m(109)
    {0x7c, 0x08, 0x04, 0x04, 0x78, 0x00}, // n(110)
    {0x38, 0x44, 0x44, 0x44, 0x38, 0x00}, // o(111)
    {0x7c, 0x14, 0x14, 0x14, 0x08, 0x00}, // p(112)
    {0x08, 0x14, 0x14, 0x14, 0x7c, 0x00}, // q(113)
    {0x7c, 0x08, 0x04, 0x04, 0x08, 0x00}, // r(114)
    {0x48, 0x54, 0x54, 0x54, 0x20, 0x00}, // s(115)
    {0x04, 0x3f, 0x44, 0x40, 0x20, 0x00}, // t(116)
    {0x3c, 0x40, 0x40, 0x20, 0x7c, 0x00}, // u(117)
    {0x1c, 0x20, 0x40, 0x20, 0x1c, 0x00}, // v(118)
    {0x3c, 0x40, 0x30, 0x40, 0x3c, 0x00}, // w(119)
    {0x44, 0x28, 0x10, 0x28, 0x44, 0x00}, // x(120)
    {0x0c, 0x50, 0x50, 0x50, 0x3c, 0x00}, // y(121)
    {0x44, 0x64, 0x54, 0x4c, 0x44, 0x00}, // z(122)
    {0x00, 0x08, 0x36, 0x41, 0x00, 0x00}, // {(123)
    {0x00, 0x00, 0x7f, 0x00, 0x00, 0x00}, // |(124)
    {0x00, 0x41, 0x36, 0x08, 0x00, 0x00}, // }(125)
    {0x08, 0x04, 0x08, 0x10, 0x08, 0x00}  // ~(126)
};

// 内部函数：I2C发送单字节(命令/数据)
static void i2c_send_byte(uint8_t reg, uint8_t data) {
    // 等待I2C总线空闲（使用WK库实际标志位）
    while (i2c_flag_get(OLED_I2C, I2C_BUSYF_FLAG));

    // 1. 发送起始信号
    i2c_start_generate(OLED_I2C);
    wk_delay_us(1);  // 确保起始信号稳定
    while (!i2c_flag_get(OLED_I2C, I2C_BUSYF_FLAG));  // 等待总线进入忙状态

    // 2. 发送从机地址(写方向)
    i2c_data_send(OLED_I2C, (OLED_I2C_ADDR << 1) | 0);  // 7位地址+写标志
    while (!i2c_flag_get(OLED_I2C, I2C_ADDRF_FLAG));     // 等待地址匹配
    i2c_flag_clear(OLED_I2C, I2C_ADDRF_FLAG);            // 清除地址标志

    // 3. 发送寄存器地址(命令/数据区分)
    i2c_data_send(OLED_I2C, reg);
    while (!i2c_flag_get(OLED_I2C, I2C_TDBE_FLAG));  // 等待发送缓冲区空

    // 4. 发送数据
    i2c_data_send(OLED_I2C, data);
    while (!i2c_flag_get(OLED_I2C, I2C_TDBE_FLAG));  // 等待发送完成

    // 5. 发送停止信号
    i2c_stop_generate(OLED_I2C);
    while (!i2c_flag_get(OLED_I2C, I2C_STOPF_FLAG));  // 等待停止信号生成
    i2c_flag_clear(OLED_I2C, I2C_STOPF_FLAG);         // 清除停止标志
}

// 内部函数：I2C批量发送
static void i2c_send_bulk(uint8_t reg, uint8_t *data, uint16_t len) {
    if (len == 0) return;

    // 等待I2C总线空闲
    while (i2c_flag_get(OLED_I2C, I2C_BUSYF_FLAG));

    // 1. 发送起始信号
    i2c_start_generate(OLED_I2C);
    wk_delay_us(1);
    while (!i2c_flag_get(OLED_I2C, I2C_BUSYF_FLAG));

    // 2. 发送从机地址(写方向)
    i2c_data_send(OLED_I2C, (OLED_I2C_ADDR << 1) | 0);
    while (!i2c_flag_get(OLED_I2C, I2C_ADDRF_FLAG));
    i2c_flag_clear(OLED_I2C, I2C_ADDRF_FLAG);

    // 3. 发送寄存器地址(命令/数据区分)
    i2c_data_send(OLED_I2C, reg);
    while (!i2c_flag_get(OLED_I2C, I2C_TDBE_FLAG));

    // 4. 批量发送数据
    for (uint16_t i = 0; i < len; i++) {
        i2c_data_send(OLED_I2C, data[i]);
        while (!i2c_flag_get(OLED_I2C, I2C_TDBE_FLAG));  // 等待发送缓冲区空
    }

    // 5. 发送停止信号
    i2c_stop_generate(OLED_I2C);
    while (!i2c_flag_get(OLED_I2C, I2C_STOPF_FLAG));
    i2c_flag_clear(OLED_I2C, I2C_STOPF_FLAG);
}

// OLED初始化
void OLED_Init(void) {
    wk_delay_ms(100);  // 上电延时

    // 初始化命令序列
    i2c_send_byte(OLED_CMD, 0xAE);  // 关闭显示
    i2c_send_byte(OLED_CMD, 0x00);  // 列地址低4位
    i2c_send_byte(OLED_CMD, 0x10);  // 列地址高4位
    i2c_send_byte(OLED_CMD, 0x40);  // 起始行地址
    i2c_send_byte(OLED_CMD, 0xB0);  // 页地址设置
    i2c_send_byte(OLED_CMD, 0x81);  // 对比度调节
    i2c_send_byte(OLED_CMD, 0xCF);  // 对比度值
    i2c_send_byte(OLED_CMD, 0xA1);  // 左右反置(0xA0正常)
    i2c_send_byte(OLED_CMD, 0xC8);  // 上下反置(0xC0正常)
    i2c_send_byte(OLED_CMD, 0xA6);  // 正常显示(0xA7反显)
    i2c_send_byte(OLED_CMD, 0xA8);  // 多路复用率设置
    i2c_send_byte(OLED_CMD, 0x3F);  // 64行
    i2c_send_byte(OLED_CMD, 0xD3);  // 显示偏移
    i2c_send_byte(OLED_CMD, 0x00);  // 无偏移
    i2c_send_byte(OLED_CMD, 0xD5);  // 时钟分频
    i2c_send_byte(OLED_CMD, 0x80);  // 默认值
    i2c_send_byte(OLED_CMD, 0xD9);  // 预充电周期
    i2c_send_byte(OLED_CMD, 0xF1);  // 预充电值
    i2c_send_byte(OLED_CMD, 0xDA);  // COM引脚配置
    i2c_send_byte(OLED_CMD, 0x12);  // 引脚配置
    i2c_send_byte(OLED_CMD, 0xDB);  // VCOMH设置
    i2c_send_byte(OLED_CMD, 0x40);  // VCOMH值
    i2c_send_byte(OLED_CMD, 0x20);  // 内存地址模式
    i2c_send_byte(OLED_CMD, 0x02);  // 页地址模式
    i2c_send_byte(OLED_CMD, 0x8D);  // 电荷泵设置
    i2c_send_byte(OLED_CMD, 0x14);  // 开启电荷泵
    i2c_send_byte(OLED_CMD, 0xAF);  // 开启显示

    OLED_Clear();  // 初始化后清屏
}

// 清屏
void OLED_Clear(void) {
    uint8_t clear_data[128] = {0};  // 128字节清零数据
    for (uint8_t page = 0; page < OLED_PAGE_COUNT; page++) {
        // 设置页地址
        i2c_send_byte(OLED_CMD, 0xB0 + page);
        i2c_send_byte(OLED_CMD, 0x00);  // 列低4位
        i2c_send_byte(OLED_CMD, 0x10);  // 列高4位
        // 连续写入128字节0
        i2c_send_bulk(OLED_DATA, clear_data, 128);
    }
}

// 开启显示
void OLED_DisplayOn(void) {
    i2c_send_byte(OLED_CMD, 0xAF);
}

// 关闭显示
void OLED_DisplayOff(void) {
    i2c_send_byte(OLED_CMD, 0xAE);
}

// 设置光标位置(x:0-127, y:0-7)
void OLED_SetPos(uint8_t x, uint8_t y) {
    i2c_send_byte(OLED_CMD, 0xB0 + y);                  // 页地址
    i2c_send_byte(OLED_CMD, (x & 0x0F));                // 列地址低4位
    i2c_send_byte(OLED_CMD, 0x10 + ((x >> 4) & 0x0F));  // 列地址高4位
}

// 显示单个字符(6x8)
void OLED_ShowChar(uint8_t x, uint8_t y, uint8_t c) {
    if (x >= OLED_WIDTH || y >= OLED_PAGE_COUNT) return;  // 超出范围

    OLED_SetPos(x, y);
    // 发送字符点阵(仅处理可打印字符)
    if (c >= ' ' && c <= '~') {
        for (uint8_t i = 0; i < 6; i++) {
            i2c_send_byte(OLED_DATA, F6x8[c - ' '][i]);
        }
    }
}

// 显示字符串
void OLED_ShowString(uint8_t x, uint8_t y, uint8_t *str) {
    uint8_t i = 0;
    while (str[i] != '\0') {
        // 换行处理(超出右边界)
        if (x + i * 6 >= OLED_WIDTH) {
            x = 0;
            y++;
            if (y >= OLED_PAGE_COUNT) y = 0;  // 循环到顶部
        }
        OLED_ShowChar(x + i * 6, y, str[i]);
        i++;
    }
}

// 显示数字(最多8位)
void OLED_ShowNumber(uint8_t x, uint8_t y, uint32_t num, uint8_t len) {
    uint8_t i, digit;
    uint32_t divisor;  // 除数：10的幂

    for (i = 0; i < len; i++) {
        // 计算除数：10^(len - i - 1)，用循环替代pow
        divisor = 1;
        for (uint8_t j = 0; j < (len - i - 1); j++) {
            divisor *= 10;
        }

        // 提取每一位数字
        digit = (num / divisor) % 10;
        OLED_ShowChar(x + i * 6, y, digit + '0');  // 转换为ASCII字符
    }
}
