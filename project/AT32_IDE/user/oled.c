#include "oled.h"

// 8x8 ASCII字模表（完整可打印字符集）
const uint8_t font8x8[][8] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // 0x20 空格
    {0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x00, 0x00}, // 0x21 !
    {0x00, 0x07, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00}, // 0x22 "
    {0x14, 0x7F, 0x14, 0x7F, 0x14, 0x00, 0x00, 0x00}, // 0x23 #
    {0x24, 0x2A, 0x7F, 0x2A, 0x12, 0x00, 0x00, 0x00}, // 0x24 $
    {0x23, 0x13, 0x08, 0x64, 0x62, 0x00, 0x00, 0x00}, // 0x25 %
    {0x36, 0x49, 0x55, 0x22, 0x50, 0x00, 0x00, 0x00}, // 0x26 &
    {0x00, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00}, // 0x27 '
    {0x00, 0x1C, 0x22, 0x41, 0x00, 0x00, 0x00, 0x00}, // 0x28 (
    {0x00, 0x41, 0x22, 0x1C, 0x00, 0x00, 0x00, 0x00}, // 0x29 )
    {0x14, 0x08, 0x3E, 0x08, 0x14, 0x00, 0x00, 0x00}, // 0x2A *
    {0x08, 0x08, 0x3E, 0x08, 0x08, 0x00, 0x00, 0x00}, // 0x2B +
    {0x00, 0x50, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00}, // 0x2C ,
    {0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00}, // 0x2D -
    {0x00, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00}, // 0x2E .
    {0x20, 0x10, 0x08, 0x04, 0x02, 0x00, 0x00, 0x00}, // 0x2F /
    {0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00, 0x00, 0x00}, // 0x30 0
    {0x00, 0x42, 0x7F, 0x40, 0x00, 0x00, 0x00, 0x00}, // 0x31 1
    {0x42, 0x61, 0x51, 0x49, 0x46, 0x00, 0x00, 0x00}, // 0x32 2
    {0x21, 0x41, 0x45, 0x4B, 0x31, 0x00, 0x00, 0x00}, // 0x33 3
    {0x18, 0x14, 0x12, 0x7F, 0x10, 0x00, 0x00, 0x00}, // 0x34 4
    {0x27, 0x45, 0x45, 0x45, 0x39, 0x00, 0x00, 0x00}, // 0x35 5
    {0x3C, 0x4A, 0x49, 0x49, 0x30, 0x00, 0x00, 0x00}, // 0x36 6
    {0x01, 0x71, 0x09, 0x05, 0x03, 0x00, 0x00, 0x00}, // 0x37 7
    {0x36, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00, 0x00}, // 0x38 8
    {0x06, 0x49, 0x49, 0x29, 0x1E, 0x00, 0x00, 0x00}, // 0x39 9
    {0x00, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00}, // 0x3A :
    {0x00, 0x56, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00}, // 0x3B ;
    {0x08, 0x14, 0x22, 0x41, 0x00, 0x00, 0x00, 0x00}, // 0x3C <
    {0x14, 0x14, 0x14, 0x14, 0x14, 0x00, 0x00, 0x00}, // 0x3D =
    {0x41, 0x22, 0x14, 0x08, 0x00, 0x00, 0x00, 0x00}, // 0x3E >
    {0x02, 0x01, 0x51, 0x09, 0x06, 0x00, 0x00, 0x00}, // 0x3F ?
    {0x32, 0x49, 0x79, 0x41, 0x3E, 0x00, 0x00, 0x00}, // 0x40 @
    {0x7E, 0x11, 0x11, 0x11, 0x7E, 0x00, 0x00, 0x00}, // 0x41 A
    {0x7F, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00, 0x00}, // 0x42 B
    {0x3E, 0x41, 0x41, 0x41, 0x22, 0x00, 0x00, 0x00}, // 0x43 C
    {0x7F, 0x41, 0x41, 0x22, 0x1C, 0x00, 0x00, 0x00}, // 0x44 D
    {0x7F, 0x49, 0x49, 0x49, 0x41, 0x00, 0x00, 0x00}, // 0x45 E
    {0x7F, 0x09, 0x09, 0x09, 0x01, 0x00, 0x00, 0x00}, // 0x46 F
    {0x3E, 0x41, 0x49, 0x49, 0x3A, 0x00, 0x00, 0x00}, // 0x47 G
    {0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00, 0x00, 0x00}, // 0x48 H
    {0x00, 0x41, 0x7F, 0x41, 0x00, 0x00, 0x00, 0x00}, // 0x49 I
    {0x20, 0x40, 0x41, 0x3F, 0x01, 0x00, 0x00, 0x00}, // 0x4A J
    {0x7F, 0x08, 0x14, 0x22, 0x41, 0x00, 0x00, 0x00}, // 0x4B K
    {0x7F, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00}, // 0x4C L
    {0x7F, 0x02, 0x0C, 0x02, 0x7F, 0x00, 0x00, 0x00}, // 0x4D M
    {0x7F, 0x04, 0x08, 0x10, 0x7F, 0x00, 0x00, 0x00}, // 0x4E N
    {0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00, 0x00, 0x00}, // 0x4F O
    {0x7F, 0x09, 0x09, 0x09, 0x06, 0x00, 0x00, 0x00}, // 0x50 P
    {0x3E, 0x41, 0x51, 0x21, 0x5E, 0x00, 0x00, 0x00}, // 0x51 Q
    {0x7F, 0x09, 0x19, 0x29, 0x46, 0x00, 0x00, 0x00}, // 0x52 R
    {0x46, 0x49, 0x49, 0x49, 0x31, 0x00, 0x00, 0x00}, // 0x53 S
    {0x01, 0x01, 0x7F, 0x01, 0x01, 0x00, 0x00, 0x00}, // 0x54 T
    {0x3F, 0x40, 0x40, 0x40, 0x3F, 0x00, 0x00, 0x00}, // 0x55 U
    {0x1F, 0x20, 0x40, 0x20, 0x1F, 0x00, 0x00, 0x00}, // 0x56 V
    {0x3F, 0x40, 0x30, 0x40, 0x3F, 0x00, 0x00, 0x00}, // 0x57 W
    {0x63, 0x14, 0x08, 0x14, 0x63, 0x00, 0x00, 0x00}, // 0x58 X
    {0x07, 0x08, 0x70, 0x08, 0x07, 0x00, 0x00, 0x00}, // 0x59 Y
    {0x61, 0x51, 0x49, 0x45, 0x43, 0x00, 0x00, 0x00}, // 0x5A Z
    {0x00, 0x7F, 0x41, 0x41, 0x00, 0x00, 0x00, 0x00}, // 0x5B [
    {0x02, 0x04, 0x08, 0x10, 0x20, 0x00, 0x00, 0x00}, // 0x5C \
    {0x00, 0x41, 0x41, 0x7F, 0x00, 0x00, 0x00, 0x00}, // 0x5D ]
    {0x04, 0x02, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00}, // 0x5E ^
    {0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00}, // 0x5F _
    {0x00, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00}, // 0x60 `
    {0x20, 0x54, 0x54, 0x54, 0x78, 0x00, 0x00, 0x00}, // 0x61 a
    {0x7F, 0x48, 0x44, 0x44, 0x38, 0x00, 0x00, 0x00}, // 0x62 b
    {0x38, 0x44, 0x44, 0x44, 0x20, 0x00, 0x00, 0x00}, // 0x63 c
    {0x38, 0x44, 0x44, 0x48, 0x7F, 0x00, 0x00, 0x00}, // 0x64 d
    {0x38, 0x54, 0x54, 0x54, 0x18, 0x00, 0x00, 0x00}, // 0x65 e
    {0x08, 0x7E, 0x09, 0x01, 0x02, 0x00, 0x00, 0x00}, // 0x66 f
    {0x0C, 0x52, 0x52, 0x52, 0x3E, 0x00, 0x00, 0x00}, // 0x67 g
    {0x7F, 0x08, 0x04, 0x04, 0x78, 0x00, 0x00, 0x00}, // 0x68 h
    {0x00, 0x44, 0x7D, 0x40, 0x00, 0x00, 0x00, 0x00}, // 0x69 i
    {0x20, 0x40, 0x44, 0x3D, 0x00, 0x00, 0x00, 0x00}, // 0x6A j
    {0x7F, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00, 0x00}, // 0x6B k
    {0x00, 0x41, 0x7F, 0x40, 0x00, 0x00, 0x00, 0x00}, // 0x6C l
    {0x7C, 0x04, 0x78, 0x04, 0x78, 0x00, 0x00, 0x00}, // 0x6D m
    {0x7C, 0x08, 0x04, 0x04, 0x78, 0x00, 0x00, 0x00}, // 0x6E n
    {0x38, 0x44, 0x44, 0x44, 0x38, 0x00, 0x00, 0x00}, // 0x6F o
    {0x7C, 0x14, 0x14, 0x14, 0x08, 0x00, 0x00, 0x00}, // 0x70 p
    {0x08, 0x14, 0x14, 0x14, 0x7C, 0x00, 0x00, 0x00}, // 0x71 q
    {0x7C, 0x08, 0x04, 0x04, 0x08, 0x00, 0x00, 0x00}, // 0x72 r
    {0x48, 0x54, 0x54, 0x54, 0x20, 0x00, 0x00, 0x00}, // 0x73 s
    {0x04, 0x3F, 0x44, 0x40, 0x20, 0x00, 0x00, 0x00}, // 0x74 t
    {0x3C, 0x40, 0x40, 0x20, 0x7C, 0x00, 0x00, 0x00}, // 0x75 u
    {0x1C, 0x20, 0x40, 0x20, 0x1C, 0x00, 0x00, 0x00}, // 0x76 v
    {0x3C, 0x40, 0x30, 0x40, 0x3C, 0x00, 0x00, 0x00}, // 0x77 w
    {0x44, 0x28, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00}, // 0x78 x
    {0x0C, 0x50, 0x50, 0x50, 0x3C, 0x00, 0x00, 0x00}, // 0x79 y
    {0x44, 0x64, 0x54, 0x4C, 0x44, 0x00, 0x00, 0x00}, // 0x7A z
    {0x00, 0x08, 0x36, 0x41, 0x00, 0x00, 0x00, 0x00}, // 0x7B {
    {0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00}, // 0x7C |
    {0x00, 0x41, 0x36, 0x08, 0x00, 0x00, 0x00, 0x00}, // 0x7D }
    {0x10, 0x08, 0x08, 0x10, 0x08, 0x00, 0x00, 0x00}  // 0x7E ~
};

/**
 * @brief 向OLED发送命令
 * @param cmd: 要发送的命令
 * @param timeout: 超时时间
 * @retval OLED_OK成功，其他为错误码
 */
static oled_status_type OLED_WriteCmd(uint8_t cmd, uint32_t timeout)
{
    uint8_t data[2] = {OLED_CMD_MODE, cmd};
    i2c_status_type ret = i2c_master_transmit(&hi2c, OLED_I2C_ADDR, data, 2, timeout);
    return (ret == I2C_OK) ? OLED_OK : OLED_ERR_I2C;
}

/**
 * @brief 向OLED发送数据
 * @param data: 要发送的数据
 * @param timeout: 超时时间
 * @retval OLED_OK成功，其他为错误码
 */
static oled_status_type OLED_WriteData(uint8_t data, uint32_t timeout)
{
    uint8_t tx_data[2] = {OLED_DATA_MODE, data};
    i2c_status_type ret = i2c_master_transmit(&hi2c, OLED_I2C_ADDR, tx_data, 2, timeout);
    return (ret == I2C_OK) ? OLED_OK : OLED_ERR_I2C;
}

/**
 * @brief 批量向OLED发送数据
 * @param pdata: 数据缓冲区指针
 * @param size: 数据长度
 * @param timeout: 超时时间
 * @retval OLED_OK成功，其他为错误码
 */
static oled_status_type OLED_WriteDataBatch(uint8_t *pdata, uint16_t size, uint32_t timeout)
{
    if (pdata == NULL || size == 0) return OLED_ERR_PARAM;

    // 构建带控制位的数据
    uint8_t *tx_buf = (uint8_t *)malloc(size + 1);
    if (tx_buf == NULL) return OLED_ERR_MEM;

    tx_buf[0] = OLED_DATA_MODE;
    memcpy(&tx_buf[1], pdata, size);

    i2c_status_type ret = i2c_master_transmit(&hi2c, OLED_I2C_ADDR, tx_buf, size + 1, timeout);
    free(tx_buf);

    return (ret == I2C_OK) ? OLED_OK : OLED_ERR_I2C;
}

/**
 * @brief 初始化OLED屏幕
 * @param timeout: 超时时间
 * @retval OLED_OK成功，其他为错误码
 */
oled_status_type OLED_Init(uint32_t timeout)
{
    oled_status_type ret;

    // 等待I2C总线就绪
    if (i2c_wait_flag(&hi2c, I2C_BUSYF_FLAG, I2C_EVENT_CHECK_NONE, timeout) != I2C_OK)
    {
        return OLED_ERR_I2C;
    }

    // SSD1306初始化序列
    ret = OLED_WriteCmd(0xAE, timeout); if (ret != OLED_OK) return ret; // 关闭显示
    ret = OLED_WriteCmd(0x00, timeout); if (ret != OLED_OK) return ret; // 列地址低4位
    ret = OLED_WriteCmd(0x10, timeout); if (ret != OLED_OK) return ret; // 列地址高4位
    ret = OLED_WriteCmd(0x40, timeout); if (ret != OLED_OK) return ret; // 起始行地址
    ret = OLED_WriteCmd(0xB0, timeout); if (ret != OLED_OK) return ret; // 页地址
    ret = OLED_WriteCmd(0x81, timeout); if (ret != OLED_OK) return ret; // 对比度设置
    ret = OLED_WriteCmd(0xFF, timeout); if (ret != OLED_OK) return ret; // 最大对比度
    ret = OLED_WriteCmd(0xA1, timeout); if (ret != OLED_OK) return ret; // 段重映射
    ret = OLED_WriteCmd(0xA6, timeout); if (ret != OLED_OK) return ret; // 正常显示
    ret = OLED_WriteCmd(0xA8, timeout); if (ret != OLED_OK) return ret; // 多路复用率
    ret = OLED_WriteCmd(0x3F, timeout); if (ret != OLED_OK) return ret; // 1/64 duty
    ret = OLED_WriteCmd(0xA4, timeout); if (ret != OLED_OK) return ret; // 正常显示模式
    ret = OLED_WriteCmd(0xD3, timeout); if (ret != OLED_OK) return ret; // 显示偏移
    ret = OLED_WriteCmd(0x00, timeout); if (ret != OLED_OK) return ret; // 无偏移
    ret = OLED_WriteCmd(0xD5, timeout); if (ret != OLED_OK) return ret; // 振荡频率
    ret = OLED_WriteCmd(0x80, timeout); if (ret != OLED_OK) return ret; // 默认值
    ret = OLED_WriteCmd(0xD9, timeout); if (ret != OLED_OK) return ret; // 预充电周期
    ret = OLED_WriteCmd(0xF1, timeout); if (ret != OLED_OK) return ret;
    ret = OLED_WriteCmd(0xDA, timeout); if (ret != OLED_OK) return ret; // COM引脚配置
    ret = OLED_WriteCmd(0x12, timeout); if (ret != OLED_OK) return ret;
    ret = OLED_WriteCmd(0xDB, timeout); if (ret != OLED_OK) return ret; // VCOMH设置
    ret = OLED_WriteCmd(0x40, timeout); if (ret != OLED_OK) return ret;
    ret = OLED_WriteCmd(0x20, timeout); if (ret != OLED_OK) return ret; // 内存地址模式
    ret = OLED_WriteCmd(0x02, timeout); if (ret != OLED_OK) return ret; // 页地址模式
    ret = OLED_WriteCmd(0x8D, timeout); if (ret != OLED_OK) return ret; // 电荷泵设置
    ret = OLED_WriteCmd(0x14, timeout); if (ret != OLED_OK) return ret; // 使能电荷泵
    ret = OLED_WriteCmd(0xAF, timeout); if (ret != OLED_OK) return ret; // 开启显示

    return OLED_Clear(timeout); // 初始化后清屏
}

/**
 * @brief 清屏操作
 * @param timeout: 超时时间
 * @retval OLED_OK成功，其他为错误码
 */
oled_status_type OLED_Clear(uint32_t timeout)
{
    uint8_t clear_data[OLED_WIDTH] = {0}; // 整行清零数据
    oled_status_type ret;

    for (uint8_t page = 0; page < OLED_PAGE_COUNT; page++)
    {
        ret = OLED_SetPos(0, page, timeout);
        if (ret != OLED_OK) return ret;

        ret = OLED_WriteDataBatch(clear_data, OLED_WIDTH, timeout);
        if (ret != OLED_OK) return ret;
    }
    return OLED_OK;
}

/**
 * @brief 开启显示
 * @param timeout: 超时时间
 * @retval OLED_OK成功，其他为错误码
 */
oled_status_type OLED_DisplayOn(uint32_t timeout)
{
    return OLED_WriteCmd(0xAF, timeout);
}

/**
 * @brief 关闭显示
 * @param timeout: 超时时间
 * @retval OLED_OK成功，其他为错误码
 */
oled_status_type OLED_DisplayOff(uint32_t timeout)
{
    return OLED_WriteCmd(0xAE, timeout);
}

/**
 * @brief 设置显示对比度
 * @param contrast: 对比度值(0-255)
 * @param timeout: 超时时间
 * @retval OLED_OK成功，其他为错误码
 */
oled_status_type OLED_SetContrast(uint8_t contrast, uint32_t timeout)
{
    oled_status_type ret;
    ret = OLED_WriteCmd(0x81, timeout); if (ret != OLED_OK) return ret;
    ret = OLED_WriteCmd(contrast, timeout); if (ret != OLED_OK) return ret;
    return OLED_OK;
}

/**
 * @brief 设置光标位置
 * @param x: 列坐标(0-127)
 * @param page: 页坐标(0-7)
 * @param timeout: 超时时间
 * @retval OLED_OK成功，其他为错误码
 */
oled_status_type OLED_SetPos(uint8_t x, uint8_t page, uint32_t timeout)
{
    if (x >= OLED_WIDTH || page >= OLED_PAGE_COUNT)
        return OLED_ERR_PARAM;

    oled_status_type ret;
    ret = OLED_WriteCmd(0xB0 + page, timeout); if (ret != OLED_OK) return ret; // 页地址
    ret = OLED_WriteCmd(0x00 + (x & 0x0F), timeout); if (ret != OLED_OK) return ret; // 列低4位
    ret = OLED_WriteCmd(0x10 + ((x >> 4) & 0x0F), timeout); if (ret != OLED_OK) return ret; // 列高4位
    return OLED_OK;
}

/**
 * @brief 绘制像素点
 * @param x: X坐标(0-127)
 * @param y: Y坐标(0-63)
 * @param timeout: 超时时间
 * @retval OLED_OK成功，其他为错误码
 */
oled_status_type OLED_DrawPixel(uint8_t x, uint8_t y, uint32_t timeout)
{
    if (x >= OLED_WIDTH || y >= OLED_HEIGHT)
        return OLED_ERR_PARAM;

    uint8_t page = y / 8;       // 计算所在页
    uint8_t bit_pos = y % 8;    // 计算页内位位置
    uint8_t pixel_data;

    // 读取当前页的当前列数据
    // (实际应用中可能需要先读取再修改，这里简化处理为直接写入)
    oled_status_type ret = OLED_SetPos(x, page, timeout);
    if (ret != OLED_OK) return ret;

    // 这里简化处理，实际应该先读取原有数据再修改
    pixel_data = 1 << bit_pos;
    ret = OLED_WriteData(pixel_data, timeout);
    return ret;
}

/**
 * @brief 绘制直线( Bresenham算法 )
 * @param x1,y1: 起点坐标
 * @param x2,y2: 终点坐标
 * @param timeout: 超时时间
 * @retval OLED_OK成功，其他为错误码
 */
oled_status_type OLED_DrawLine(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, uint32_t timeout)
{
    int16_t dx = (x2 > x1) ? (x2 - x1) : (x1 - x2);
    int16_t dy = (y2 > y1) ? (y2 - y1) : (y1 - y2);
    int16_t sx = (x2 > x1) ? 1 : -1;
    int16_t sy = (y2 > y1) ? 1 : -1;
    int16_t err = dx - dy;
    int16_t e2;

    oled_status_type ret = OLED_OK;

    while (1)
    {
        ret = OLED_DrawPixel((uint8_t)x1, (uint8_t)y1, timeout);
        if (ret != OLED_OK) return ret;

        if (x1 == x2 && y1 == y2) break;

        e2 = 2 * err;
        if (e2 > -dy)
        {
            err -= dy;
            x1 += sx;
        }
        if (e2 < dx)
        {
            err += dx;
            y1 += sy;
        }
    }
    return OLED_OK;
}

/**
 * @brief 显示一个字符(8x8)
 * @param x: 起始列坐标
 * @param page: 页坐标
 * @param c: 要显示的字符(ASCII)
 * @param timeout: 超时时间
 * @retval OLED_OK成功，其他为错误码
 */
oled_status_type OLED_ShowChar(uint8_t x, uint8_t page, char c, uint32_t timeout)
{
    if (c < 0x20 || c > 0x7E)  // 只支持可打印ASCII字符
        return OLED_ERR_PARAM;

    uint8_t idx = c - 0x20;    // 计算字模索引
    oled_status_type ret;

    ret = OLED_SetPos(x, page, timeout);
    if (ret != OLED_OK) return ret;

    return OLED_WriteDataBatch((uint8_t *)font8x8[idx], 8, timeout);
}

/**
 * @brief 显示字符串(8x8)
 * @param x: 起始列坐标
 * @param page: 页坐标
 * @param str: 要显示的字符串
 * @param timeout: 超时时间
 * @retval OLED_OK成功，其他为错误码
 */
oled_status_type OLED_ShowString(uint8_t x, uint8_t page, const char *str, uint32_t timeout)
{
    if (str == NULL) return OLED_ERR_PARAM;

    oled_status_type ret = OLED_OK;
    uint8_t curr_x = x;

    while (*str != '\0' && ret == OLED_OK)
    {
        if (curr_x + 8 > OLED_WIDTH)  // 超出屏幕范围
            break;

        ret = OLED_ShowChar(curr_x, page, *str, timeout);
        curr_x += 8;  // 每个字符占8列
        str++;
    }
    return ret;
}

/**
 * @brief 显示数字（8x8）
 * @param x: 起始列坐标
 * @param page: 页坐标
 * @param num: 要显示的数字
 * @param len: 数字位数
 * @param timeout: 超时时间
 * @retval OLED_OK成功，其他为错误码
 */
oled_status_type OLED_ShowNumber(uint8_t x, uint8_t page, uint32_t num, uint8_t len, uint32_t timeout)
{
    if (len == 0 || len > 10)  // 最多支持10位数字
        return OLED_ERR_PARAM;

    oled_status_type ret = OLED_OK;
    uint8_t curr_x = x;
    uint8_t digit;
    uint32_t divisor = 1;

    // 计算除数（如len=6则divisor=100000）
    for (uint8_t i = 0; i < len - 1; i++)
    {
        divisor *= 10;
    }

    for (uint8_t i = 0; i < len; i++)
    {
        if (curr_x + 8 > OLED_WIDTH)  // 超出屏幕范围
            break;

        // 提取每一位数字
        digit = (num / divisor) % 10;
        divisor /= 10;

        // 显示单个数字（利用字符显示函数，数字'0'-'9'对应ASCII 48-57）
        ret = OLED_ShowChar(curr_x, page, '0' + digit, timeout);
        if (ret != OLED_OK)
            return ret;

        curr_x += 8;  // 每个数字占8列
    }

    return ret;
}
